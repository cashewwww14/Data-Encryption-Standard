<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DES Encryption/Decryption Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 1.1em;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .input-group small {
            display: block;
            margin-top: 5px;
            color: #666;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-encrypt {
            background: #10b981;
            color: white;
        }

        .btn-encrypt:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-decrypt {
            background: #3b82f6;
            color: white;
        }

        .btn-decrypt:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
        }

        .btn-clear {
            background: #ef4444;
            color: white;
        }

        .btn-clear:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .result-section {
            margin-top: 30px;
            padding: 25px;
            background: #f0fdf4;
            border-radius: 10px;
            border-left: 5px solid #10b981;
        }

        .result-section h3 {
            color: #059669;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .result-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #d1fae5;
        }

        .result-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .result-value {
            font-family: 'Courier New', monospace;
            word-break: break-all;
            color: #059669;
            font-size: 0.95em;
        }

        .visualization-section {
            margin-top: 30px;
        }

        .visualization-section h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
            text-align: center;
        }

        .step {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .step:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .step-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 1.2em;
        }

        .step-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #333;
        }

        .step-content {
            padding-left: 55px;
        }

        .step-detail {
            background: #f9fafb;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .step-detail-label {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 5px;
        }

        .step-detail-value {
            color: #333;
            word-break: break-all;
        }

        .round-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .round-box {
            background: #fef3c7;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #f59e0b;
        }

        .round-box-title {
            font-weight: 600;
            color: #b45309;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .round-box-value {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #78350f;
            word-break: break-all;
        }

        .error-section {
            background: #fee2e2;
            border: 2px solid #ef4444;
            color: #991b1b;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-weight: 600;
        }

        .bits-display {
            display: inline-block;
            margin: 2px;
            padding: 2px 4px;
            background: #dbeafe;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }

        .hex-display {
            background: #fce7f3;
            padding: 10px;
            border-radius: 6px;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
            color: #831843;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .button-group {
                flex-direction: column;
            }

            .round-container {
                grid-template-columns: 1fr;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }

        .loading.active {
            display: block;
        }

        .info-box {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 6px;
        }

        .info-box strong {
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê DES Encryption/Decryption Visualizer</h1>
            <p>Visualisasi Step-by-Step Algoritma DES dengan Detail Lengkap</p>
        </div>

        <div class="content">
            <div class="info-box">
                <strong>‚ÑπÔ∏è Informasi:</strong> DES (Data Encryption Standard) adalah block cipher 64-bit dengan key 64-bit (56-bit efektif). 
                Algoritma ini menggunakan 16 Feistel rounds dengan automatic PKCS7 padding untuk plaintext dengan ukuran berapapun.
            </div>

            <div class="input-section">
                <div class="input-group">
                    <label for="plaintext">üìù Plaintext:</label>
                    <textarea id="plaintext" placeholder="Masukkan plaintext yang ingin di-encrypt/decrypt...">Hello DES!</textarea>
                    <small>Bisa memasukkan text dengan panjang berapapun (akan di-padding otomatis)</small>
                </div>

                <div class="input-group">
                    <label for="key">üîë Key (8 bytes):</label>
                    <input type="text" id="key" placeholder="8 karakter key" value="SecKey01" maxlength="8">
                    <small>Key harus tepat 8 karakter (64 bits)</small>
                </div>

                <div class="button-group">
                    <button class="btn-encrypt" onclick="processEncryption()">üîí Encrypt</button>
                    <button class="btn-decrypt" onclick="processDecryption()">üîì Decrypt</button>
                    <button class="btn-clear" onclick="clearResults()">üóëÔ∏è Clear</button>
                </div>
            </div>

            <div class="loading" id="loading">
                ‚è≥ Processing...
            </div>

            <div id="results"></div>
            <div id="visualization"></div>
        </div>
    </div>

    <script>
        // DES Implementation - Ported from Python
        const IP = [58, 50, 42, 34, 26, 18, 10, 2,
                    60, 52, 44, 36, 28, 20, 12, 4,
                    62, 54, 46, 38, 30, 22, 14, 6,
                    64, 56, 48, 40, 32, 24, 16, 8,
                    57, 49, 41, 33, 25, 17, 9, 1,
                    59, 51, 43, 35, 27, 19, 11, 3,
                    61, 53, 45, 37, 29, 21, 13, 5,
                    63, 55, 47, 39, 31, 23, 15, 7];

        const FP = [40, 8, 48, 16, 56, 24, 64, 32,
                    39, 7, 47, 15, 55, 23, 63, 31,
                    38, 6, 46, 14, 54, 22, 62, 30,
                    37, 5, 45, 13, 53, 21, 61, 29,
                    36, 4, 44, 12, 52, 20, 60, 28,
                    35, 3, 43, 11, 51, 19, 59, 27,
                    34, 2, 42, 10, 50, 18, 58, 26,
                    33, 1, 41, 9, 49, 17, 57, 25];

        const PC1 = [57, 49, 41, 33, 25, 17, 9,
                     1, 58, 50, 42, 34, 26, 18,
                     10, 2, 59, 51, 43, 35, 27,
                     19, 11, 3, 60, 52, 44, 36,
                     63, 55, 47, 39, 31, 23, 15,
                     7, 62, 54, 46, 38, 30, 22,
                     14, 6, 61, 53, 45, 37, 29,
                     21, 13, 5, 28, 20, 12, 4];

        const PC2 = [14, 17, 11, 24, 1, 5,
                     3, 28, 15, 6, 21, 10,
                     23, 19, 12, 4, 26, 8,
                     16, 7, 27, 20, 13, 2,
                     41, 52, 31, 37, 47, 55,
                     30, 40, 51, 45, 33, 48,
                     44, 49, 39, 56, 34, 53,
                     46, 42, 50, 36, 29, 32];

        const E = [32, 1, 2, 3, 4, 5,
                   4, 5, 6, 7, 8, 9,
                   8, 9, 10, 11, 12, 13,
                   12, 13, 14, 15, 16, 17,
                   16, 17, 18, 19, 20, 21,
                   20, 21, 22, 23, 24, 25,
                   24, 25, 26, 27, 28, 29,
                   28, 29, 30, 31, 32, 1];

        const SBOXES = [
            [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
             [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
             [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
             [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],

            [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
             [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
             [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
             [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

            [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
             [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
             [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
             [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

            [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
             [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
             [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
             [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

            [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
             [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
             [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
             [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

            [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
             [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
             [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
             [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

            [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
             [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
             [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
             [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

            [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
             [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
             [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
             [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
        ];

        const P = [16, 7, 20, 21,
                   29, 12, 28, 17,
                   1, 15, 23, 26,
                   5, 18, 31, 10,
                   2, 8, 24, 14,
                   32, 27, 3, 9,
                   19, 13, 30, 6,
                   22, 11, 4, 25];

        const SHIFT_SCHEDULE = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

        // Global variable to store visualization data
        let visualizationData = {};

        function permute(block, table) {
            return table.map(i => block[i - 1]);
        }

        function bitlistFromBytes(data) {
            const bits = [];
            for (let byte of data) {
                for (let bit = 7; bit >= 0; bit--) {
                    bits.push((byte >> bit) & 1);
                }
            }
            return bits;
        }

        function bytesFromBitlist(bits) {
            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                const chunk = bits.slice(i, i + 8);
                const byteValue = parseInt(chunk.join(''), 2);
                bytes.push(byteValue);
            }
            return new Uint8Array(bytes);
        }

        function leftShift(bits, n) {
            return bits.slice(n).concat(bits.slice(0, n));
        }

        function xorBits(a, b) {
            return a.map((bit, i) => bit ^ b[i]);
        }

        function sboxSubstitution(bits) {
            const output = [];
            for (let i = 0; i < 8; i++) {
                const chunk = bits.slice(i * 6, (i + 1) * 6);
                const row = (chunk[0] << 1) | chunk[5];
                const column = (chunk[1] << 3) | (chunk[2] << 2) | (chunk[3] << 1) | chunk[4];
                const value = SBOXES[i][row][column];
                for (let bit = 3; bit >= 0; bit--) {
                    output.push((value >> bit) & 1);
                }
            }
            return output;
        }

        function generateRoundKeys(keyBytes) {
            visualizationData.keyGeneration = [];
            const keyBits = bitlistFromBytes(keyBytes);
            const permuted = permute(keyBits, PC1);
            let c = permuted.slice(0, 28);
            let d = permuted.slice(28);
            
            visualizationData.keyGeneration.push({
                step: 'Initial',
                description: 'Key after PC1 permutation',
                c: c.join(''),
                d: d.join('')
            });

            const roundKeys = [];
            for (let round = 0; round < 16; round++) {
                c = leftShift(c, SHIFT_SCHEDULE[round]);
                d = leftShift(d, SHIFT_SCHEDULE[round]);
                const combined = c.concat(d);
                const roundKey = permute(combined, PC2);
                roundKeys.push(roundKey);
                
                visualizationData.keyGeneration.push({
                    round: round + 1,
                    shift: SHIFT_SCHEDULE[round],
                    c: c.join(''),
                    d: d.join(''),
                    key: roundKey.join('')
                });
            }
            return roundKeys;
        }

        function feistel(right, subkey, roundNum) {
            const expanded = permute(right, E);
            const xored = xorBits(expanded, subkey);
            const substituted = sboxSubstitution(xored);
            const permuted = permute(substituted, P);
            
            if (roundNum !== undefined) {
                visualizationData.rounds[roundNum].expansion = expanded.join('');
                visualizationData.rounds[roundNum].xorResult = xored.join('');
                visualizationData.rounds[roundNum].sboxResult = substituted.join('');
                visualizationData.rounds[roundNum].pPermutation = permuted.join('');
            }
            
            return permuted;
        }

        function desProcess(blockBytes, roundKeys, encrypt) {
            visualizationData.rounds = [];
            
            const blockBits = bitlistFromBytes(blockBytes);
            const permuted = permute(blockBits, IP);
            let left = permuted.slice(0, 32);
            let right = permuted.slice(32);
            
            visualizationData.initialPermutation = {
                original: blockBits.join(''),
                permuted: permuted.join(''),
                left: left.join(''),
                right: right.join('')
            };

            const keys = encrypt ? roundKeys : roundKeys.slice().reverse();
            
            for (let i = 0; i < 16; i++) {
                visualizationData.rounds.push({
                    round: i + 1,
                    leftBefore: left.join(''),
                    rightBefore: right.join(''),
                    subkey: keys[i].join('')
                });
                
                const feistelResult = feistel(right, keys[i], i);
                const newRight = xorBits(left, feistelResult);
                left = right;
                right = newRight;
                
                visualizationData.rounds[i].leftAfter = left.join('');
                visualizationData.rounds[i].rightAfter = right.join('');
            }

            const combined = right.concat(left);
            const finalBits = permute(combined, FP);
            
            visualizationData.finalPermutation = {
                combined: combined.join(''),
                final: finalBits.join('')
            };

            return bytesFromBitlist(finalBits);
        }

        function pkcs7Pad(data, blockSize = 8) {
            const paddingLen = blockSize - (data.length % blockSize);
            const padding = new Uint8Array(paddingLen).fill(paddingLen);
            const result = new Uint8Array(data.length + paddingLen);
            result.set(data);
            result.set(padding, data.length);
            return result;
        }

        function pkcs7Unpad(data) {
            if (data.length === 0) {
                throw new Error("Invalid padding: empty data");
            }
            const paddingLen = data[data.length - 1];
            if (paddingLen < 1 || paddingLen > 8) {
                throw new Error("Invalid padding length");
            }
            for (let i = 1; i <= paddingLen; i++) {
                if (data[data.length - i] !== paddingLen) {
                    throw new Error("Invalid padding bytes");
                }
            }
            return data.slice(0, -paddingLen);
        }

        function desEncrypt(plaintext, key) {
            if (key.length !== 8) {
                throw new Error("DES key must be exactly 8 bytes");
            }
            
            visualizationData = { blocks: [] };
            const roundKeys = generateRoundKeys(key);
            const padded = pkcs7Pad(plaintext);
            
            visualizationData.padding = {
                original: plaintext,
                padded: padded,
                paddingLength: padded.length - plaintext.length
            };
            
            const ciphertextBlocks = [];
            for (let offset = 0; offset < padded.length; offset += 8) {
                const block = padded.slice(offset, offset + 8);
                visualizationData.currentBlock = offset / 8;
                const cipherBlock = desProcess(block, roundKeys, true);
                ciphertextBlocks.push(cipherBlock);
                visualizationData.blocks.push({
                    blockNum: offset / 8 + 1,
                    plaintext: block,
                    ciphertext: cipherBlock,
                    rounds: visualizationData.rounds,
                    initialPermutation: visualizationData.initialPermutation,
                    finalPermutation: visualizationData.finalPermutation
                });
            }
            
            const result = new Uint8Array(ciphertextBlocks.reduce((acc, block) => acc + block.length, 0));
            let offset = 0;
            for (let block of ciphertextBlocks) {
                result.set(block, offset);
                offset += block.length;
            }
            return result;
        }

        function desDecrypt(ciphertext, key) {
            if (key.length !== 8) {
                throw new Error("DES key must be exactly 8 bytes");
            }
            if (ciphertext.length % 8 !== 0) {
                throw new Error("Ciphertext length must be a multiple of 8 bytes");
            }
            
            visualizationData = { blocks: [] };
            const roundKeys = generateRoundKeys(key);
            
            const plaintextBlocks = [];
            for (let offset = 0; offset < ciphertext.length; offset += 8) {
                const block = ciphertext.slice(offset, offset + 8);
                visualizationData.currentBlock = offset / 8;
                const plainBlock = desProcess(block, roundKeys, false);
                plaintextBlocks.push(plainBlock);
                visualizationData.blocks.push({
                    blockNum: offset / 8 + 1,
                    ciphertext: block,
                    plaintext: plainBlock,
                    rounds: visualizationData.rounds,
                    initialPermutation: visualizationData.initialPermutation,
                    finalPermutation: visualizationData.finalPermutation
                });
            }
            
            const paddedPlaintext = new Uint8Array(plaintextBlocks.reduce((acc, block) => acc + block.length, 0));
            let offset = 0;
            for (let block of plaintextBlocks) {
                paddedPlaintext.set(block, offset);
                offset += block.length;
            }
            
            return pkcs7Unpad(paddedPlaintext);
        }

        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        function formatBits(bits, groupSize = 8) {
            let result = '';
            for (let i = 0; i < bits.length; i += groupSize) {
                if (i > 0) result += ' ';
                result += bits.substring(i, i + groupSize);
            }
            return result;
        }

        function processEncryption() {
            try {
                document.getElementById('loading').classList.add('active');
                document.getElementById('results').innerHTML = '';
                document.getElementById('visualization').innerHTML = '';

                const plaintext = document.getElementById('plaintext').value;
                const key = document.getElementById('key').value;

                if (key.length !== 8) {
                    throw new Error("Key harus tepat 8 karakter!");
                }

                const encoder = new TextEncoder();
                const plaintextBytes = encoder.encode(plaintext);
                const keyBytes = encoder.encode(key);

                const ciphertext = desEncrypt(plaintextBytes, keyBytes);
                const ciphertextHex = bytesToHex(ciphertext);

                displayResults(plaintext, key, ciphertextHex, 'encrypt');
                displayVisualization('encrypt');

                document.getElementById('loading').classList.remove('active');
            } catch (error) {
                document.getElementById('loading').classList.remove('active');
                displayError(error.message);
            }
        }

        function processDecryption() {
            try {
                document.getElementById('loading').classList.add('active');
                document.getElementById('results').innerHTML = '';
                document.getElementById('visualization').innerHTML = '';

                const ciphertextHex = document.getElementById('plaintext').value;
                const key = document.getElementById('key').value;

                if (key.length !== 8) {
                    throw new Error("Key harus tepat 8 karakter!");
                }

                const encoder = new TextEncoder();
                const keyBytes = encoder.encode(key);
                const ciphertextBytes = hexToBytes(ciphertextHex);

                const plaintext = desDecrypt(ciphertextBytes, keyBytes);
                const decoder = new TextDecoder();
                const plaintextStr = decoder.decode(plaintext);

                displayResults(plaintextStr, key, ciphertextHex, 'decrypt');
                displayVisualization('decrypt');

                document.getElementById('loading').classList.remove('active');
            } catch (error) {
                document.getElementById('loading').classList.remove('active');
                displayError(error.message);
            }
        }

        function displayResults(text, key, hex, mode) {
            const resultsDiv = document.getElementById('results');
            const isEncrypt = mode === 'encrypt';

            resultsDiv.innerHTML = `
                <div class="result-section">
                    <h3>‚úÖ Hasil ${isEncrypt ? 'Enkripsi' : 'Dekripsi'}</h3>
                    <div class="result-box">
                        <div class="result-label">${isEncrypt ? 'üìù Plaintext' : 'üîì Decrypted Text'}:</div>
                        <div class="result-value">${text}</div>
                    </div>
                    <div class="result-box">
                        <div class="result-label">üîë Key:</div>
                        <div class="result-value">${key}</div>
                    </div>
                    <div class="result-box">
                        <div class="result-label">${isEncrypt ? 'üîí Ciphertext (Hex)' : 'üîí Ciphertext Input (Hex)'}:</div>
                        <div class="result-value">${hex}</div>
                    </div>
                    ${isEncrypt && visualizationData.padding ? `
                    <div class="result-box">
                        <div class="result-label">üì¶ Padding Info:</div>
                        <div class="result-value">
                            Original Length: ${visualizationData.padding.original.length} bytes<br>
                            Padded Length: ${visualizationData.padding.padded.length} bytes<br>
                            Padding Added: ${visualizationData.padding.paddingLength} bytes (PKCS7)
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        function displayVisualization(mode) {
            const vizDiv = document.getElementById('visualization');
            let html = '<div class="visualization-section"><h3>üîç Visualisasi Step-by-Step</h3>';

            // Key Generation
            if (visualizationData.keyGeneration) {
                html += `
                    <div class="step">
                        <div class="step-header">
                            <div class="step-number">1</div>
                            <div class="step-title">Key Generation (Generate 16 Round Keys)</div>
                        </div>
                        <div class="step-content">
                            <div class="step-detail">
                                <div class="step-detail-label">PC1 Permutation:</div>
                                <div class="step-detail-value">
                                    C0: ${formatBits(visualizationData.keyGeneration[0].c, 7)}<br>
                                    D0: ${formatBits(visualizationData.keyGeneration[0].d, 7)}
                                </div>
                            </div>
                            <div class="round-container">
                `;

                for (let i = 1; i <= 16; i++) {
                    const kg = visualizationData.keyGeneration[i];
                    html += `
                        <div class="round-box">
                            <div class="round-box-title">Round ${i} (Shift: ${kg.shift})</div>
                            <div class="round-box-value">
                                Key: ${formatBits(kg.key, 6)}
                            </div>
                        </div>
                    `;
                }

                html += `
                            </div>
                        </div>
                    </div>
                `;
            }

            // Process each block
            if (visualizationData.blocks) {
                visualizationData.blocks.forEach((block, blockIdx) => {
                    html += `
                        <div class="step">
                            <div class="step-header">
                                <div class="step-number">${blockIdx + 2}</div>
                                <div class="step-title">Block ${block.blockNum} - Initial Permutation (IP)</div>
                            </div>
                            <div class="step-content">
                                <div class="step-detail">
                                    <div class="step-detail-label">Input Block (64 bits):</div>
                                    <div class="step-detail-value">${formatBits(block.initialPermutation.original)}</div>
                                    <div class="hex-display">${bytesToHex(mode === 'encrypt' ? block.plaintext : block.ciphertext)}</div>
                                </div>
                                <div class="step-detail">
                                    <div class="step-detail-label">After IP:</div>
                                    <div class="step-detail-value">
                                        L0: ${formatBits(block.initialPermutation.left)}<br>
                                        R0: ${formatBits(block.initialPermutation.right)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // 16 Rounds
                    html += `
                        <div class="step">
                            <div class="step-header">
                                <div class="step-number">${blockIdx + 3}</div>
                                <div class="step-title">Block ${block.blockNum} - 16 Feistel Rounds</div>
                            </div>
                            <div class="step-content">
                    `;

                    block.rounds.forEach((round, roundIdx) => {
                        html += `
                            <div class="round-box" style="margin-bottom: 15px; background: #fef3c7; padding: 15px;">
                                <div class="round-box-title" style="font-size: 1.1em; margin-bottom: 10px;">
                                    üîÑ Round ${round.round}
                                </div>
                                <div style="font-size: 0.85em; line-height: 1.6;">
                                    <strong>Input:</strong><br>
                                    L${roundIdx}: ${formatBits(round.leftBefore, 8)}<br>
                                    R${roundIdx}: ${formatBits(round.rightBefore, 8)}<br><br>
                                    
                                    <strong>F-Function:</strong><br>
                                    1Ô∏è‚É£ Expansion (32‚Üí48): ${formatBits(round.expansion, 6)}<br>
                                    2Ô∏è‚É£ XOR with Key: ${formatBits(round.xorResult, 6)}<br>
                                    3Ô∏è‚É£ S-Box (48‚Üí32): ${formatBits(round.sboxResult, 4)}<br>
                                    4Ô∏è‚É£ P-Permutation: ${formatBits(round.pPermutation, 4)}<br><br>
                                    
                                    <strong>Output:</strong><br>
                                    L${roundIdx + 1}: ${formatBits(round.leftAfter, 8)}<br>
                                    R${roundIdx + 1}: ${formatBits(round.rightAfter, 8)}
                                </div>
                            </div>
                        `;
                    });

                    html += `
                            </div>
                        </div>
                    `;

                    // Final Permutation
                    html += `
                        <div class="step">
                            <div class="step-header">
                                <div class="step-number">${blockIdx + 4}</div>
                                <div class="step-title">Block ${block.blockNum} - Final Permutation (FP)</div>
                            </div>
                            <div class="step-content">
                                <div class="step-detail">
                                    <div class="step-detail-label">Before FP (R16 + L16):</div>
                                    <div class="step-detail-value">${formatBits(block.finalPermutation.combined)}</div>
                                </div>
                                <div class="step-detail">
                                    <div class="step-detail-label">After FP (Final Output):</div>
                                    <div class="step-detail-value">${formatBits(block.finalPermutation.final)}</div>
                                    <div class="hex-display">${bytesToHex(mode === 'encrypt' ? block.ciphertext : block.plaintext)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
            }

            html += '</div>';
            vizDiv.innerHTML = html;
        }

        function displayError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="error-section">
                    ‚ùå Error: ${message}
                </div>
            `;
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('visualization').innerHTML = '';
            document.getElementById('plaintext').value = '';
            document.getElementById('key').value = '';
        }
    </script>
</body>
</html>